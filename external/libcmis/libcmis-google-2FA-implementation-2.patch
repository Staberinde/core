diff --git a/src/libcmis/oauth2-providers.cxx b/src/libcmis/oauth2-providers.cxx
--- a/src/libcmis/oauth2-providers.cxx
+++ b/src/libcmis/oauth2-providers.cxx
@@ -29,57 +29,168 @@
 #include <libxml/HTMLparser.h>
 #include <libxml/xmlreader.h>

+#include "session-factory.hxx"
 #include "oauth2-providers.hxx"
 #include "http-session.hxx"

+#define CHALLENGE_PAGE_ACTION "/signin"
+#define CHALLENGE_PAGE_ACTION_LEN sizeof( CHALLENGE_PAGE_ACTION ) - 1
+#define PIN_FORM_ACTION "/signin/challenge/ipp"
+#define PIN_FORM_ACTION_LEN sizeof( PIN_FORM_ACTION ) - 1
+#define PIN_INPUT_NAME "Pin"
+
 using namespace std;

 string OAuth2Providers::OAuth2Gdrive( HttpSession* session, const string& authUrl,
                                       const string& username, const string& password )
 {
+    /* This member function implements 'Google OAuth 2.0'
+     *
+     * The interaction is carried out by libcmis, with no web browser involved.
+     *
+     * Normal sequence (without 2FA) is:
+     * 1) a get to activate login page
+     *    receive first login page, html format
+     * 2) subsequent post to sent email
+     *    receive html page for password input
+     * 3) subsequent post to send password
+     *    receive html page for application consent
+     * 4) subsequent post to send a consent for the application
+     *    receive a single-use authorization code
+     *    this code is returned as a string
+     *
+     * Sequence with 2FA is:
+     * 1) a get to activate login page
+     *    receive first login page, html format
+     * 2) subsequent post to sent email
+     *    receive html page for password input
+     * 3) subsequent post to send password
+     *    receive html page for pin input
+     * 3b) subsequent post to send pin number
+     *    receive html page for application consent
+     * 4) subsequent post to send a consent for the application
+     *    receive a single-use authorization code
+     *    this code is returned as a string
+     */
+
     static const string CONTENT_TYPE( "application/x-www-form-urlencoded" );
-    // STEP 1: Log in
+    // STEP 1: get login page
     string res;
     try
     {
+        // send the first get, receive the html login page
         res = session->httpGetRequest( authUrl )->getStream( )->str( );
     }
-    catch ( const CurlException& e )
+    catch ( const CurlException& )
     {
         return string( );
     }

-    string loginPost, loginLink;
-    if ( !parseResponse( res.c_str( ), loginPost, loginLink ) )
+    // STEP 2: send email
+
+    string loginEmailPost, loginEmailLink;
+    if ( !parseResponse( res.c_str( ), loginEmailPost, loginEmailLink ) )
         return string( );

-    loginPost += "Email=";
-    loginPost += string( username );
-    loginPost += "&Passwd=";
-    loginPost += string( password );
+    loginEmailPost += "Email=";
+    loginEmailPost += string( username );

-    istringstream loginIs( loginPost );
-    string loginRes;
+    istringstream loginEmailIs( loginEmailPost );
+    string loginEmailRes;
     try
     {
-        loginRes = session->httpPostRequest ( loginLink, loginIs, CONTENT_TYPE )
+        // send a post with user email, receive the html page for password input
+        loginEmailRes = session->httpPostRequest ( loginEmailLink, loginEmailIs, CONTENT_TYPE )
                         ->getStream( )->str( );
     }
-    catch ( const CurlException& e )
+    catch ( const CurlException& )
+    {
+        return string( );
+    }
+
+    // STEP 3: password page
+
+    string loginPasswdPost, loginPasswdLink;
+    if ( !parseResponse( loginEmailRes.c_str( ), loginPasswdPost, loginPasswdLink ) )
+        return string( );
+
+    loginPasswdPost += "Passwd=";
+    loginPasswdPost += string( password );
+
+    istringstream loginPasswdIs( loginPasswdPost );
+    string loginPasswdRes;
+    try
+    {
+        // send a post with user password, receive the application consent page
+        loginPasswdRes = session->httpPostRequest ( loginPasswdLink, loginPasswdIs, CONTENT_TYPE )
+                        ->getStream( )->str( );
+    }
+    catch ( const CurlException& )
     {
         return string( );
     }

-    // STEP 2: allow libcmis to access google drive
     string approvalPost, approvalLink;
-    if ( !parseResponse( loginRes. c_str( ), approvalPost, approvalLink) )
+    if ( !parseResponse( loginPasswdRes. c_str( ), approvalPost, approvalLink) )
         return string( );
+
+    // when 2FA is enabled, link doesn't start with 'http'
+    if ( approvalLink.compare(0, 4, "http") != 0 )
+    {
+        // STEP 3b: 2 Factor Authentication, pin code request
+
+        string loginChallengePost( approvalPost );
+        string loginChallengeLink( approvalLink );
+
+        libcmis::OAuth2AuthCodeProvider fallbackProvider = libcmis::SessionFactory::getOAuth2AuthCodeProvider( );
+        string pin( fallbackProvider( "", "", "" ) );
+
+        if( pin.empty() )
+        {
+            // unset OAuth2AuthCode Provider to avoid showing pin request again in the HttpSession::oauth2Authenticate
+            libcmis::SessionFactory::setOAuth2AuthCodeProvider( NULL );
+            return string( );
+        }
+
+        loginChallengeLink = "https://accounts.google.com" + loginChallengeLink;
+        loginChallengePost += string( PIN_INPUT_NAME ) + "=";
+        loginChallengePost += string( pin );
+
+        istringstream loginChallengeIs( loginChallengePost );
+        string loginChallengeRes;
+        try
+        {
+            // send a post with pin, receive the application consent page
+            loginChallengeRes = session->httpPostRequest ( loginChallengeLink, loginChallengeIs, CONTENT_TYPE )
+                            ->getStream( )->str( );
+        }
+        catch ( const CurlException& )
+        {
+            return string( );
+        }
+
+        approvalPost = string();
+        approvalLink = string();
+
+        if ( !parseResponse( loginChallengeRes. c_str( ), approvalPost, approvalLink) )
+            return string( );
+    }
+    else if( approvalLink.compare( "https://accounts.google.com/ServiceLoginAuth" ) == 0 )
+    {
+        // wrong password,
+        // unset OAuth2AuthCode Provider to avoid showing pin request again in the HttpSession::oauth2Authenticate
+        libcmis::SessionFactory::setOAuth2AuthCodeProvider( NULL );
+        return string( );
+    }
+
+    // STEP 4: allow libcmis to access google drive
     approvalPost += "submit_access=true";

     istringstream approvalIs( approvalPost );
     string approvalRes;
     try
     {
+        // send a post with application consent
         approvalRes = session->httpPostRequest ( approvalLink, approvalIs,
                             CONTENT_TYPE) ->getStream( )->str( );
     }
@@ -88,7 +199,7 @@
         throw e.getCmisException( );
     }

-    // STEP 3: Take the authentication code from the text bar
+    // Take the authentication code from the text bar
     string code = parseCode( approvalRes.c_str( ) );

     return code;
@@ -111,7 +222,7 @@
     {
         res = session->httpGetRequest( authUrl )->getStream( )->str( );
     }
-    catch ( const CurlException& e )
+    catch ( const CurlException& )
     {
         return string( );
     }
@@ -137,7 +248,7 @@
         // Alfresco code is in the redirect link
         resp = session->httpPostRequest( loginLink, loginIs, CONTENT_TYPE, false );
     }
-    catch ( const CurlException& e )
+    catch ( const CurlException& )
     {
         return string( );
     }
@@ -179,6 +290,11 @@
     if ( doc == NULL ) return 0;
     xmlTextReaderPtr reader =   xmlReaderWalker( doc );
     if ( reader == NULL ) return 0;
+
+    bool readInputField = false;
+    bool bIsRightForm = false;
+    bool bHasPinField = false;
+
     while ( true )
     {
         // Go to the next node, quit if not found
@@ -188,22 +304,45 @@
         // Find the redirect link
         if ( xmlStrEqual( nodeName, BAD_CAST( "form" ) ) )
         {
+            // 2FA: Don't add fields form other forms not having pin field
+            if ( bIsRightForm && !bHasPinField )
+                post = string( "" );
+            if ( bIsRightForm && bHasPinField )
+                break;
+
             xmlChar* action = xmlTextReaderGetAttribute( reader,
                                                          BAD_CAST( "action" ));
+
+            // GDrive pin code page contains many forms.
+            // We have to parse only the form with pin field.
             if ( action != NULL )
             {
-                if ( xmlStrlen(action) > 0)
+                bool bChallengePage = ( strncmp( (char*)action,
+                                                 CHALLENGE_PAGE_ACTION,
+                                                 CHALLENGE_PAGE_ACTION_LEN ) == 0 );
+                bIsRightForm = ( strncmp( (char*)action,
+                                                 PIN_FORM_ACTION,
+                                                 PIN_FORM_ACTION_LEN ) == 0 );
+                if ( ( xmlStrlen( action ) > 0 )
+                    && ( ( bChallengePage && bIsRightForm ) || !bChallengePage ) )
+                {
                     link = string ( (char*) action);
+                    readInputField = true;
+                }
+                else
+                    readInputField = false;
                 xmlFree (action);
             }
         }
         // Find input values
-        if ( !xmlStrcmp( nodeName, BAD_CAST( "input" ) ) )
+        if ( readInputField && !xmlStrcmp( nodeName, BAD_CAST( "input" ) ) )
         {
             xmlChar* name = xmlTextReaderGetAttribute( reader,
                                                        BAD_CAST( "name" ));
             xmlChar* value = xmlTextReaderGetAttribute( reader,
                                                         BAD_CAST( "value" ));
+            if ( name != NULL && strcmp( (char*)name, PIN_INPUT_NAME ) == 0 )
+                bHasPinField = true;
             if ( ( name != NULL ) && ( value!= NULL ) )
             {
                 if ( ( xmlStrlen( name ) > 0) && ( xmlStrlen( value ) > 0) )
